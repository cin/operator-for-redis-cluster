"use strict";(self.webpackChunkoperator_for_redis_cluster=self.webpackChunkoperator_for_redis_cluster||[]).push([[253],{6708:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"key-migration","title":"Key Migration","description":"Overview","source":"@site/docs/key-migration.md","sourceDirName":".","slug":"/key-migration","permalink":"/operator-for-redis-cluster/key-migration","draft":false,"unlisted":false,"editUrl":"https://cin.github.io/operator-for-redis-cluster/docs/key-migration.md","tags":[],"version":"current","lastUpdatedAt":1749862110000,"frontMatter":{"title":"Key Migration","slug":"/key-migration"},"sidebar":"docs","previous":{"title":"Rolling Update Procedure","permalink":"/operator-for-redis-cluster/rolling-update"},"next":{"title":"Contributing","permalink":"/operator-for-redis-cluster/contributing"}}');var o=n(4848),a=n(8453);const s={title:"Key Migration",slug:"/key-migration"},r="Key Migration",l={},c=[{value:"Overview",id:"overview",level:2},{value:"Redis cluster migration configuration",id:"redis-cluster-migration-configuration",level:2},{value:"Default",id:"default",level:3},{value:"Definitions",id:"definitions",level:3},{value:"Rolling update key migration enabled - <code>rollingUpdate.keyMigration: true</code>",id:"rolling-update-key-migration-enabled---rollingupdatekeymigration-true",level:3},{value:"Examples",id:"examples",level:4},{value:"Rolling update key migration disabled - <code>rollingUpdate.keyMigration: false</code>",id:"rolling-update-key-migration-disabled---rollingupdatekeymigration-false",level:3},{value:"Examples",id:"examples-1",level:4}];function d(e){const i={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(i.header,{children:(0,o.jsx)(i.h1,{id:"key-migration",children:"Key Migration"})}),"\n",(0,o.jsx)(i.h2,{id:"overview",children:"Overview"}),"\n",(0,o.jsxs)(i.p,{children:["Key migration is the process by which Redis migrates keys from a source primary node to a destination primary node. The high-level steps for migrating keys can be found ",(0,o.jsx)(i.a,{href:"https://redis.io/commands/cluster-setslot#redis-cluster-live-resharding-explained",children:"here"}),". This feature allows users to better configure how keys are migrated, if at all."]}),"\n",(0,o.jsx)(i.p,{children:"Depending on the size of the Redis cluster, the key migration process can be time-consuming. For example, a cluster with thousands of Gigabytes of data can take hours to migrate keys during a scaling or rolling update operation. To speed up the scaling process, we give users the option to migrate slots without keys and provide configuration to control batching."}),"\n",(0,o.jsx)(i.h2,{id:"redis-cluster-migration-configuration",children:"Redis cluster migration configuration"}),"\n",(0,o.jsx)(i.h3,{id:"default",children:"Default"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-yaml",children:"rollingUpdate:\n  keyMigration: true\n  keyBatchSize: 10000\n  slotBatchSize: 16\n  idleTimeoutMillis: 30000\n  warmingDelayMillis: 0\n\nscaling:\n  keyBatchSize: 10000\n  slotBatchSize: 16\n  idleTimeoutMillis: 30000\n"})}),"\n",(0,o.jsxs)(i.p,{children:["If you observe the default configuration above, you will notice that there are two separate sections for configuring key migration during rolling updates and scaling operations. The ",(0,o.jsx)(i.code,{children:"rollingUpdate"})," section determines how keys are migrated during ",(0,o.jsx)(i.a,{href:"/operator-for-redis-cluster/rolling-update",children:"rolling updates"}),", and the ",(0,o.jsx)(i.code,{children:"scaling"})," section determines how keys are migrated during ",(0,o.jsx)(i.a,{href:"/operator-for-redis-cluster/scaling",children:"scaling operations"}),". The following definitions apply to both configurations."]}),"\n",(0,o.jsx)(i.h3,{id:"definitions",children:"Definitions"}),"\n",(0,o.jsxs)(i.p,{children:[(0,o.jsx)(i.code,{children:"keyMigration"})," specifies whether to migrate keys during rolling updates. For most use cases, users will want to keep this value set to ",(0,o.jsx)(i.code,{children:"true"}),". However, for users who use Redis cluster as a caching tool instead of a persistent database, you may want to consider setting this to ",(0,o.jsx)(i.code,{children:"false"}),". When set to ",(0,o.jsx)(i.code,{children:"false"}),", this feature will transfer slots from the old Redis primary to the new primary without migrating keys. For large clusters, this can save a significant amount of time with the tradeoff of temporarily increasing the number of requests to the backend. The increase in backend hit rate can be mitigated by modifying ",(0,o.jsx)(i.code,{children:"warmingDelayMillis"}),". The next sections will discuss the two different configuration options for key migration."]}),"\n",(0,o.jsxs)(i.p,{children:[(0,o.jsx)(i.code,{children:"keyBatchSize"})," determines the number of keys to get from a single slot during each migration iteration. By default, this value is ",(0,o.jsx)(i.code,{children:"10000"})," keys."]}),"\n",(0,o.jsxs)(i.p,{children:[(0,o.jsx)(i.code,{children:"slotBatchSize"})," specifies the number of slots to migrate on each iteration. By default, this value is ",(0,o.jsx)(i.code,{children:"16"})," slots. For most use cases, set this value to the number of logical CPUs. Usually, this is two times the CPU resource limits in the Redis operator deployment. See ",(0,o.jsx)(i.a,{href:"https://pkg.go.dev/runtime#NumCPU",children:"runtime.CPU"})," for more information on how Go checks the number of available CPUs. Also, keep in mind a Redis cluster has ",(0,o.jsx)(i.code,{children:"16384"})," total slots, and those slots are evenly distributed across the primary nodes."]}),"\n",(0,o.jsxs)(i.p,{children:[(0,o.jsx)(i.code,{children:"idleTimeoutMillis"})," is the maximum idle time at any point during key migration. This means the migration should make progress without blocking for more than the specified number of milliseconds. See the ",(0,o.jsx)(i.a,{href:"https://redis.io/commands/migrate",children:"Redis migrate command"})," for more information about the timeout."]}),"\n",(0,o.jsxs)(i.p,{children:[(0,o.jsx)(i.code,{children:"warmingDelayMillis"})," is the amount of time in between each batch of slots. As the name suggests, it allows the new Redis node to warm its cache before moving on to the next node in the rolling update."]}),"\n",(0,o.jsxs)(i.h3,{id:"rolling-update-key-migration-enabled---rollingupdatekeymigration-true",children:["Rolling update key migration enabled - ",(0,o.jsx)(i.code,{children:"rollingUpdate.keyMigration: true"})]}),"\n",(0,o.jsxs)(i.p,{children:[(0,o.jsx)(i.code,{children:"keyBatchSize"}),": change this value depending on the total number of keys in your Redis cluster. Increasing this value can reduce the amount of time it takes to migrate keys by moving a larger number of keys per batch of slots."]}),"\n",(0,o.jsxs)(i.p,{children:[(0,o.jsx)(i.code,{children:"slotBatchSize"}),": increasing this value higher than the number of logical CPUs will have minimal effect on rolling update performance."]}),"\n",(0,o.jsxs)(i.p,{children:[(0,o.jsx)(i.code,{children:"idleTimeoutMillis"}),": do not modify this value unless you receive this specific error."]}),"\n",(0,o.jsxs)(i.p,{children:[(0,o.jsx)(i.code,{children:"warmingDelayMillis"}),": it's best to set this value to zero unless you want to introduce a delay between slot migrations. You can still set a non-zero delay if you want to reduce the overall strain on the cluster by the migration calls, and you do not care about how long the migration takes."]}),"\n",(0,o.jsx)(i.h4,{id:"examples",children:"Examples"}),"\n",(0,o.jsx)(i.p,{children:"Assume all clusters have allocated 4 physical CPUs and 1 Gb memory for the Redis operator. We have 8 logical CPUs."}),"\n",(0,o.jsx)(i.p,{children:"Given a small redis cluster with 3 primaries, RF = 1, and maximum memory of 1 Gb per node - we have the following configuration:"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-yaml",children:"rollingUpdate:                # For rolling updates,\n  keyMigration: true          # Key migration is enabled\n  keyBatchSize: 1000          # Migrate keys in batches of 1,000 per slot \n  slotBatchSize: 8            # Transfer 8 slots on each migration iteration\n  idleTimeoutMillis: 30000    # Wait up to 30 seconds for any delay in communication during the migration\n  warmingDelayMillis: 0       # No delay between each batch of 2,500 slots\n\nscaling:                      # For scaling operations,\n  keyBatchSize: 1000          # Migrate keys in batches of 1,000 per slot\n  slotBatchSize: 8            # Transfer 8 slots on each migration iteration\n  idleTimeoutMillis: 30000    # Wait up to 30 seconds for any delay in communication during the migration\n"})}),"\n",(0,o.jsx)(i.p,{children:"Given a large redis cluster with 20 primaries, RF = 1, and maximum memory of 10 Gb per node:"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-yaml",children:"rollingUpdate:                # For rolling updates,\n  keyMigration: true          # Key migration is enabled\n  keyBatchSize: 10000         # Migrate keys in batches of 10,000 per slot\n  slotBatchSize: 8            # Transfer 8 slots on each migration iteration\n  idleTimeoutMillis: 30000    # Wait up to 30 seconds for any delay in communication during the migration\n  warmingDelayMillis: 0       # No delay between each batch of slots\n\nscaling:                      # For scaling operations,\n  keyBatchSize: 10000         # Migrate keys in batches of 10,000 per slot\n  slotBatchSize: 8            # Transfer 8 slots on each migration iteration\n  idleTimeoutMillis: 30000    # Wait up to 30 seconds for any delay in communication during the migration\n"})}),"\n",(0,o.jsxs)(i.p,{children:["Observe how ",(0,o.jsx)(i.code,{children:"keyBatchSize"})," is significantly greater than in the previous example because we have ten times the data per node."]}),"\n",(0,o.jsx)(i.p,{children:"Here we have a cluster with 10 primaries, RF = 1, and maximum memory of 5Gb per node. We optimize for fast key migration on both rolling updates and scaling operations:"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-yaml",children:"rollingUpdate:                # For rolling updates,\n  keyMigration: true          # Key migration is enabled\n  keyBatchSize: 50000         # Migrate keys in batches of 50,000 per slot\n  slotBatchSize: 8            # Transfer 8 slots on each migration iteration\n  idleTimeoutMillis: 30000    # Wait up to 30 seconds for any delay in communication during the migration\n  warmingDelayMillis: 0       # No delay between each batch of slots\n\nscaling:                      # For scaling operations,\n  keyBatchSize: 50000         # Migrate keys in batches of 50,000 per slot\n  slotBatchSize: 8            # Transfer 8 slots on each migration iteration\n  idleTimeoutMillis: 30000    # Wait up to 30 seconds for any delay in communication during the migration\n"})}),"\n",(0,o.jsxs)(i.h3,{id:"rolling-update-key-migration-disabled---rollingupdatekeymigration-false",children:["Rolling update key migration disabled - ",(0,o.jsx)(i.code,{children:"rollingUpdate.keyMigration: false"})]}),"\n",(0,o.jsxs)(i.p,{children:[(0,o.jsx)(i.code,{children:"keyBatchSize"}),": not used when no keys are migrated."]}),"\n",(0,o.jsxs)(i.p,{children:[(0,o.jsx)(i.code,{children:"slotBatchSize"}),": depends on how quickly you want to wipe the cache. You can use a smaller ",(0,o.jsx)(i.code,{children:"slotBatchSize"})," and increase ",(0,o.jsx)(i.code,{children:"warmingDelayMillis"})," to make this process go slower. If your backend can handle a higher increase in requests, you can set ",(0,o.jsx)(i.code,{children:"warmingDelayMillis"})," to something small or even zero."]}),"\n",(0,o.jsxs)(i.p,{children:[(0,o.jsx)(i.code,{children:"idleTimeoutMillis"}),": not used in when no keys are migrated."]}),"\n",(0,o.jsxs)(i.p,{children:[(0,o.jsx)(i.code,{children:"warmingDelayMillis"}),": increasing this value will ease the strain on your backend as slot ownership transfers during a rolling update by pausing after migrating a single batch of slots."]}),"\n",(0,o.jsxs)(i.p,{children:["Please be sure to properly configure ",(0,o.jsx)(i.code,{children:"rollingUpdate"})," based on your Redis cluster if you plan on using this configuration. Setting too small a value for ",(0,o.jsx)(i.code,{children:"warmingDelayMillis"})," will quickly wipe all the keys in your cluster without yielding sufficient time for new Redis nodes to warm up."]}),"\n",(0,o.jsx)(i.h4,{id:"examples-1",children:"Examples"}),"\n",(0,o.jsx)(i.p,{children:"Given a small redis cluster with 3 primaries, RF = 1, and maximum memory of 1 Gb per node - we have the following configuration:"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-yaml",children:"rollingUpdate:                # For rolling updates,\n  keyMigration: false         # Key migration is disabled\n  slotBatchSize: 8            # Transfer 8 slots on each migration iteration\n  warmingDelayMillis: 1000    # Wait 1 second between each batch of slots\n\nscaling:                      # For scaling operations,\n  keyBatchSize: 10000         # Migrate keys in batches of 10,000 per slot\n  slotBatchSize: 8            # Transfer 8 slots on each migration iteration\n  idleTimeoutMillis: 30000    # Wait up to 30 seconds for any delay in communication during the migration\n"})}),"\n",(0,o.jsx)(i.p,{children:"Given a large redis cluster with 20 primaries, RF = 1, and maximum memory of 10 Gb per node:"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-yaml",children:"rollingUpdate:                # For rolling updates,\n  keyMigration: false         # Key migration is disabled\n  slotBatchSize: 8            # Transfer 8 slots on each migration iteration\n  warmingDelayMillis: 10000   # Wait 10 seconds between each batch of slots\n\nscaling:                      # For scaling operations,\n  keyBatchSize: 10000         # Migrate keys in batches of 10,000 per slot\n  slotBatchSize: 8            # Transfer 8 slots on each migration iteration\n  idleTimeoutMillis: 30000    # Wait up to 30 seconds for any delay in communication during the migration\n"})}),"\n",(0,o.jsx)(i.p,{children:"Here we have a cluster with 10 primaries, RF = 1, and maximum memory of 5Gb per node. We want to wipe the cache as quickly as possible on rolling updates, while also maintaining fast key migration on scaling operations:"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-yaml",children:"rollingUpdate:                # For rolling updates,\n  keyMigration: false         # Key migration is disabled\n  slotBatchSize: 8            # Transfer 8 slots on each migration iteration\n  warmingDelayMillis: 0       # No delay between each batch of slots\n\nscaling:                      # For scaling operations,\n  keyBatchSize: 50000         # Migrate keys in batches of 50,000 per slot\n  slotBatchSize: 8            # Transfer 8 slots on each migration iteration\n  idleTimeoutMillis: 30000    # Wait up to 30 seconds for any delay in communication during the migration\n"})})]})}function h(e={}){const{wrapper:i}={...(0,a.R)(),...e.components};return i?(0,o.jsx)(i,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>s,x:()=>r});var t=n(6540);const o={},a=t.createContext(o);function s(e){const i=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function r(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),t.createElement(a.Provider,{value:i},e.children)}}}]);