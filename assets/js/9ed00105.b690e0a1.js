"use strict";(self.webpackChunkoperator_for_redis_cluster=self.webpackChunkoperator_for_redis_cluster||[]).push([[4],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>f});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),u=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=u(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=u(n),f=i,m=p["".concat(l,".").concat(f)]||p[f]||d[f]||o;return n?a.createElement(m,r(r({ref:t},c),{},{components:n})):a.createElement(m,r({ref:t},c))}));function f(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var u=2;u<o;u++)r[u]=n[u];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},9733:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>u});var a=n(7462),i=(n(7294),n(3905));const o={title:"Redis Server Configuration",slug:"/configuration"},r="Redis Server Configuration",s={unversionedId:"configuration",id:"configuration",title:"Redis Server Configuration",description:"Overview",source:"@site/docs/configuration.md",sourceDirName:".",slug:"/configuration",permalink:"/operator-for-redis-cluster/configuration",draft:!1,editUrl:"https://ibm.github.io/operator-for-redis-cluster/docs/configuration.md",tags:[],version:"current",lastUpdatedAt:1673626398,formattedLastUpdatedAt:"Jan 13, 2023",frontMatter:{title:"Redis Server Configuration",slug:"/configuration"},sidebar:"docs",previous:{title:"Kubectl Plugin",permalink:"/operator-for-redis-cluster/kubectl-plugin"},next:{title:"Scaling Operations",permalink:"/operator-for-redis-cluster/scaling"}},l={},u=[{value:"Overview",id:"overview",level:2},{value:"Redis Cluster Configuration",id:"redis-cluster-configuration",level:2},{value:"Configuration Options",id:"configuration-options",level:2},{value:"Defaults",id:"defaults",level:3},{value:"Persistence",id:"persistence",level:3},{value:"Snapshotting",id:"snapshotting",level:4},{value:"Max Memory",id:"max-memory",level:3},{value:"Eviction Policies",id:"eviction-policies",level:3},{value:"Overriding redis.conf",id:"overriding-redisconf",level:2},{value:"Configuration Examples",id:"configuration-examples",level:3},{value:"Redis as a Database",id:"redis-as-a-database",level:4},{value:"Redis as a Cache",id:"redis-as-a-cache",level:4}],c={toc:u};function d(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"redis-server-configuration"},"Redis Server Configuration"),(0,i.kt)("h2",{id:"overview"},"Overview"),(0,i.kt)("p",null,"A Redis server can be configured by providing a Redis configuration file called ",(0,i.kt)("inlineCode",{parentName:"p"},"redis.conf"),". To read more about the format of this file, see the ",(0,i.kt)("a",{parentName:"p",href:"https://redis.io/topics/config"},"configuration documentation"),"."),(0,i.kt)("h2",{id:"redis-cluster-configuration"},"Redis Cluster Configuration"),(0,i.kt)("p",null,"The Redis operator manages clusters that operate in ",(0,i.kt)("strong",{parentName:"p"},"cluster mode"),". This means every node in the cluster specifies the ",(0,i.kt)("inlineCode",{parentName:"p"},"cluster-enabled yes")," configuration option. It also means that every node in the cluster will have the same configuration. You do not need to set ",(0,i.kt)("inlineCode",{parentName:"p"},"cluster-enabled")," explicitly in your configuration because we automatically add the setting if it is not present when a Redis pod starts."),(0,i.kt)("p",null,"Redis clusters that operate in cluster mode support data sharding, which is essential to ensuring high availability. See the ",(0,i.kt)("a",{parentName:"p",href:"https://redis.io/topics/cluster-spec"},"Redis cluster specification")," to learn more."),(0,i.kt)("h2",{id:"configuration-options"},"Configuration Options"),(0,i.kt)("p",null,"There are various configuration options you will want to consider whether you are using Redis as a cache or as a persistent database. We urge you to read the ",(0,i.kt)("a",{parentName:"p",href:"https://raw.githubusercontent.com/redis/redis/6.2/redis.conf"},"Redis configuration documentation")," to understand the tradeoffs for each option."),(0,i.kt)("h3",{id:"defaults"},"Defaults"),(0,i.kt)("p",null,"A Redis server is able to start without specifying a ",(0,i.kt)("inlineCode",{parentName:"p"},"redis.conf")," configuration file or providing override configuration; it will instead use the default settings. We do not recommend using the defaults in a production environment, as your Redis database can quickly exceed the amount of memory allocated to your Redis pods. Our operator currently deploys and manages Redis clusters using Redis 6.2. Read the default configuration for ",(0,i.kt)("a",{parentName:"p",href:"https://raw.githubusercontent.com/redis/redis/6.2/redis.conf"},"Redis 6.2")," to learn more about the specific settings."),(0,i.kt)("h3",{id:"persistence"},"Persistence"),(0,i.kt)("p",null,"If you use Redis as a database, you will need to enable persistence. Redis provides multiple persistence options, such as Redis Database (RDB) and Append Only File (AOF). You can read more about the advantages and disadvantages of each persistence option in the ",(0,i.kt)("a",{parentName:"p",href:"https://redis.io/topics/persistence"},"persistence documentation"),"."),(0,i.kt)("h4",{id:"snapshotting"},"Snapshotting"),(0,i.kt)("p",null,"To quote the Redis documentation:"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"By default Redis saves snapshots of the dataset on disk, in a binary file called dump.rdb. You can configure Redis to have it save the dataset every N seconds if there are at least M changes in the dataset, or you can manually call the SAVE or BGSAVE commands.")),(0,i.kt)("p",null,"Using the default settings, snapshotting will occur:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"after 3600 sec (60 min) if at least 1 key changed"),(0,i.kt)("li",{parentName:"ul"},"after 300 sec (5 min) if at least 10 keys changed"),(0,i.kt)("li",{parentName:"ul"},"after 60 sec if at least 10000 keys changed")),(0,i.kt)("p",null,"Snapshots can be extremely useful for backups and faster restarts. We recommend configuring ",(0,i.kt)("inlineCode",{parentName:"p"},"save")," to a reasonable value depending on the number of requests per second your database processes."),(0,i.kt)("p",null,"If you use Redis as a cache, be sure to disable snapshotting by setting ",(0,i.kt)("inlineCode",{parentName:"p"},'save ""')," in ",(0,i.kt)("inlineCode",{parentName:"p"},"redis.conf"),". For a large Redis cluster processing thousands of requests per second, disk can fill up fairly quickly with database snapshots. Disabling snapshotting will prevent Redis from dumping the entire dataset to disk all together."),(0,i.kt)("h3",{id:"max-memory"},"Max Memory"),(0,i.kt)("p",null,"To quote the Redis documentation:"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"The ",(0,i.kt)("inlineCode",{parentName:"p"},"maxmemory")," configuration directive is used in order to configure Redis to use a specified amount of memory for the data set.")),(0,i.kt)("p",null,"We highly encourage setting ",(0,i.kt)("inlineCode",{parentName:"p"},"maxmemory")," to a value lower than the allocated memory to each Redis pod. By default, we set ",(0,i.kt)("inlineCode",{parentName:"p"},"maxmemory")," to 70% of the allocated Redis pod memory. You should change this value depending on how much additional memory the Redis process consumes doing other operations."),(0,i.kt)("h3",{id:"eviction-policies"},"Eviction Policies"),(0,i.kt)("p",null,"See ",(0,i.kt)("a",{parentName:"p",href:"https://redis.io/topics/lru-cache"},"Using Redis as an LRU cache")," to learn more about which ",(0,i.kt)("inlineCode",{parentName:"p"},"maxmemory-policy")," is best for your needs. If you use Redis as a database, you will likely want to keep the default ",(0,i.kt)("inlineCode",{parentName:"p"},"maxmemory-policy")," set to ",(0,i.kt)("inlineCode",{parentName:"p"},"noeviction"),"."),(0,i.kt)("h2",{id:"overriding-redisconf"},"Overriding redis.conf"),(0,i.kt)("p",null,"You have two separate options for overriding the default ",(0,i.kt)("inlineCode",{parentName:"p"},"redis.conf")," when deploying a Redis cluster. The first is to specify your configuration as key-value pairs in ",(0,i.kt)("inlineCode",{parentName:"p"},"redis.configuration.valueMap"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},'redis:\n  configuration:\n    valueMap:\n      maxmemory-policy: "volatile-lfu"\n      maxmemory: "10Gb"\n      ...\n')),(0,i.kt)("p",null,"Note: be sure to always quote values if you decide to use this approach."),(0,i.kt)("p",null,"The second option is to specify ",(0,i.kt)("inlineCode",{parentName:"p"},"redis.configuration.file")," with the path to your ",(0,i.kt)("inlineCode",{parentName:"p"},"redis.conf")," file. For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},'redis:\n  configuration:\n    file: "/path/to/redis.conf"\n')),(0,i.kt)("p",null,"Your ",(0,i.kt)("inlineCode",{parentName:"p"},"redis.conf")," file should have the same format as any Redis configuration file:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"maxmemory-policy volatile-lfu\nmaxmemory 10gb\n...\n")),(0,i.kt)("p",null,"Note: do ",(0,i.kt)("strong",{parentName:"p"},"not")," quote values in Redis configuration files."),(0,i.kt)("h3",{id:"configuration-examples"},"Configuration Examples"),(0,i.kt)("h4",{id:"redis-as-a-database"},"Redis as a Database"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},'redis:\n  configuration:\n    valueMap:\n      maxmemory-policy: "noeviction"       # Do not evict keys even if memory is full\n      maxmemory: "100gb"\n      save: "3600 1 300 10 60 10000"       # Enable RDB persistence to perform snapshots (see Snapshotting section)\n      appendonly: "yes"                    # Enable AOF persistence\n      \n')),(0,i.kt)("h4",{id:"redis-as-a-cache"},"Redis as a Cache"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},'redis:\n  configuration:\n    valueMap:\n      maxmemory-policy: "volatile-lfu"      # Expire keys based on least frequently used policy\n      maxmemory: "10gb"\n      save: ""                              # Disable saving snapshots of the database to disk\n      lazyfree-lazy-eviction: "yes"         # Asynchronously evict keys\n      lazyfree-lazy-expire: "yes"           # Asynchronously delete expired keys\n      lazyfree-lazy-server-del: "yes"       # Asynchronously delete keys during specific server commands\n      replica-lazy-flush: "yes"             # Asynchronously flush keys after replica resynchronization\n      cluster-require-full-coverage: "no"   # Accept queries even when only part of key space is covered\n      cluster-allow-reads-when-down: "yes"  # Allow nodes to serve reads while cluster is down\n')))}d.isMDXComponent=!0}}]);