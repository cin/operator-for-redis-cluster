"use strict";(self.webpackChunkoperator_for_redis_cluster=self.webpackChunkoperator_for_redis_cluster||[]).push([[806],{6569:(e,r,o)=>{o.r(r),o.d(r,{assets:()=>l,contentTitle:()=>d,default:()=>p,frontMatter:()=>s,metadata:()=>t,toc:()=>a});const t=JSON.parse('{"id":"rolling-update","title":"Rolling Update Procedure","description":"Overview","source":"@site/docs/rolling-update.md","sourceDirName":".","slug":"/rolling-update","permalink":"/operator-for-redis-cluster/rolling-update","draft":false,"unlisted":false,"editUrl":"https://cin.github.io/operator-for-redis-cluster/docs/rolling-update.md","tags":[],"version":"current","lastUpdatedAt":1749862110000,"frontMatter":{"title":"Rolling Update Procedure","slug":"/rolling-update"},"sidebar":"docs","previous":{"title":"Scaling Operations","permalink":"/operator-for-redis-cluster/scaling"},"next":{"title":"Key Migration","permalink":"/operator-for-redis-cluster/key-migration"}}');var n=o(4848),i=o(8453);const s={title:"Rolling Update Procedure",slug:"/rolling-update"},d="Rolling Update Procedure",l={},a=[{value:"Overview",id:"overview",level:2},{value:"Redis cluster upgrades",id:"redis-cluster-upgrades",level:2},{value:"Resource limitations",id:"resource-limitations",level:2}];function c(e){const r={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(r.header,{children:(0,n.jsx)(r.h1,{id:"rolling-update-procedure",children:"Rolling Update Procedure"})}),"\n",(0,n.jsx)(r.h2,{id:"overview",children:"Overview"}),"\n",(0,n.jsx)(r.p,{children:"In production, developers aim for zero downtime when periodically deploying newer versions of their application. Per Kubernetes documentation:"}),"\n",(0,n.jsxs)(r.blockquote,{children:["\n",(0,n.jsx)(r.p,{children:"rolling updates allow Deployments' update to take place with zero downtime by incrementally updating Pods instances with new ones"}),"\n"]}),"\n",(0,n.jsxs)(r.p,{children:["To learn more about how rolling updates work in k8s, see ",(0,n.jsx)(r.a,{href:"https://kubernetes.io/docs/tutorials/kubernetes-basics/update/update-intro/",children:"Performing a Rolling Update"}),"."]}),"\n",(0,n.jsx)(r.h2,{id:"redis-cluster-upgrades",children:"Redis cluster upgrades"}),"\n",(0,n.jsxs)(r.p,{children:["A rolling update occurs when the user applies a change to the Redis cluster pod template spec. For example, a user might update the Redis cluster pod image tag in ",(0,n.jsx)(r.code,{children:"charts/node-for-redis/values.yaml"})," and run ",(0,n.jsx)(r.code,{children:"helm upgrade"}),". When the Redis operator detects the pod template spec change, the following procedure takes place:"]}),"\n",(0,n.jsxs)(r.ol,{children:["\n",(0,n.jsxs)(r.li,{children:["Compare the number of running Redis pods with the number of pods required for the rolling update:","\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{children:"# migration pods = 1 + replication factor\n# required pods = # primaries x # migration pods\n# pods to create = # required pods + # migration pods - # of running pods\n"})}),"\n","where ",(0,n.jsx)(r.code,{children:"# migration pods"})," is the number of pods needed to migrate one primary and all of its replicas, ",(0,n.jsx)(r.code,{children:"# required pods"})," is the total number of pods required for the cluster, and ",(0,n.jsx)(r.code,{children:"# pods to create"})," is the number of pods to create on a single rolling update iteration."]}),"\n",(0,n.jsxs)(r.li,{children:["If ",(0,n.jsx)(r.code,{children:"# pods to create > 0"}),", create additional pods with the new pod template spec."]}),"\n",(0,n.jsx)(r.li,{children:"Separate old nodes and new nodes according to their pod spec hash annotation."}),"\n",(0,n.jsx)(r.li,{children:"Select the old primary node to replace with one of the newly created pods."}),"\n",(0,n.jsx)(r.li,{children:"Generate the primary to replicas mapping for the newly created pods."}),"\n",(0,n.jsx)(r.li,{children:"Attach the new replicas to the new primary."}),"\n",(0,n.jsx)(r.li,{children:"Migrate slots (and by default, keys) from the old primary to the new primary."}),"\n",(0,n.jsx)(r.li,{children:"Detach, forget, and delete the old pods."}),"\n"]}),"\n",(0,n.jsxs)(r.p,{children:["The Redis cluster rolling update procedure ensures that there is no downtime as new nodes replace old ones. However, because the migration of keys from old primaries to new ones is a time intensive operation, you may see a temporary decrease in the performance of your cluster during this process. To learn more about step 7, see ",(0,n.jsx)(r.a,{href:"/operator-for-redis-cluster/key-migration",children:"key migration"}),"."]}),"\n",(0,n.jsx)(r.h2,{id:"resource-limitations",children:"Resource limitations"}),"\n",(0,n.jsxs)(r.p,{children:["This procedure requires additional resources beyond what is normally allocated to the Redis cluster. More specifically, this procedure creates an extra ",(0,n.jsx)(r.code,{children:"1 + replication factor"})," pods on each rolling update iteration, so you will need ensure that you have allocated sufficient resources. For standard configurations that allow multiple pods per node, you may need to increase memory + cpu on your existing nodes. If you have configured your cluster topology to limit one Redis pod per k8s node, you may need to increase the number of k8s nodes in your worker pool."]}),"\n",(0,n.jsxs)(r.p,{children:["In the case where there are insufficient resources to schedule new Redis pods, the pods will get stuck in ",(0,n.jsx)(r.code,{children:"Pending"})," state. This state is difficult to recover from because the Redis operator will continue to apply the rolling update procedure until it completes. If you find your newly created pods are in ",(0,n.jsx)(r.code,{children:"Pending"})," state, increase the allocated memory + cpus."]})]})}function p(e={}){const{wrapper:r}={...(0,i.R)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},8453:(e,r,o)=>{o.d(r,{R:()=>s,x:()=>d});var t=o(6540);const n={},i=t.createContext(n);function s(e){const r=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function d(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:s(e.components),t.createElement(i.Provider,{value:r},e.children)}}}]);